# 개선이 필요한 부분

### 벡터 DB용 데이터 만들 때 주의 사항
 - 자료 조사 + JSON 파싱(구조화된 데이터 추출)를 1번에 하면 안 된다.
 - 자료 조사를 따로 하고 그 내용을 바탕으로 json으로 변환했어야 한다.

현재 프로젝트의 벡터 DB 구조를 분석해보니, 직접 ChromaDB 클라이언트를 사용하고 있는 것을 확인했습니다. LangChain Retriever를 사용하면 몇 가지 중요한 장점들이 있습니다:

# 🎯 LangChain Retriever 사용의 장점

## 1. **표준화된 인터페이스**
현재 방식은 각 벡터 데이터베이스마다 다른 API를 직접 호출해야 하지만, Retriever는 모든 벡터 데이터베이스에 대해 동일한 `.invoke()` 메서드로 통일된 인터페이스를 제공합니다. 이로 인해 코드 일관성이 높아지고 유지보수가 편해집니다.

## 2. **LCEL 파이프라인 자동 통합**
현재는 벡터 검색을 별도로 수행한 후 결과를 수동으로 프롬프트에 조합해야 하지만, Retriever는 LCEL 파이프라인 안에서 자동으로 실행되어 검색부터 응답 생성까지 하나의 체인으로 매끄럽게 연결됩니다.

## 3. **고급 검색 기능**
- **Multi-Query Retriever**: 하나의 질문을 여러 각도로 변형하여 더 포괄적인 검색 결과 제공
- **Self-Query Retriever**: 자연어 질문에서 메타데이터 필터링 조건을 자동으로 파악하여 적용
- **Parent Document Retriever**: 작은 청크로 검색한 후 관련된 전체 문서를 가져와 더 풍부한 컨텍스트 제공

## 4. **Document 객체 사용의 핵심 장점**

### **구조화된 데이터 관리**
현재 딕셔너리 기반의 불규칙한 데이터 구조에서 Document 객체의 표준화된 구조(`page_content`와 `metadata`)로 전환하면 데이터 일관성과 가독성이 크게 향상됩니다.

### **메타데이터 일관성**
Document 객체는 모든 LangChain 도구에서 일관된 방식으로 접근할 수 있으며, 안전한 메타데이터 접근(`metadata.get()`)을 통해 런타임 에러 위험을 줄입니다.

### **LangChain 도구와 완벽 호환**
Text Splitter, Vector Store, 각종 Retriever 등 LangChain 생태계의 모든 도구들이 Document 객체를 직접 처리할 수 있어 별도 변환 작업이 불필요합니다.

### **필터링 및 후처리 편의성**
메타데이터 기반 필터링, 품질 기반 정렬, 출처별 그룹핑 등의 작업이 표준화된 속성을 통해 훨씬 간단하고 직관적으로 수행 가능합니다.

### **디버깅 및 추적 용이성**
검색 결과의 출처, 유사도, 챕터 정보 등을 체계적으로 추적할 수 있어 답변 품질 분석과 시스템 디버깅이 매우 용이해집니다.

## 5. **QnA 에이전트 활용**
현재 QnA 에이전트에서 Function Calling 방식 대신 Retriever Tool을 사용하면, Document 객체를 반환하는 표준화된 도구로 더 간단하고 강력한 검색이 가능해집니다. Agent가 Document 객체를 자동으로 이해하고 처리할 수 있습니다.

## 🔧 현재 프로젝트 적용 방안

### **단계적 도입 전략**
ChromaRetrieverManager 클래스를 만들어 이론 생성용과 QnA용 리트리버를 각각 최적화하여 제공할 수 있습니다. 이론용은 높은 품질 임계값으로, QnA용은 다양성을 위해 MMR(Maximal Marginal Relevance) 방식을 사용하는 것이 효과적입니다.

### **기존 코드와 호환성 유지**
새로운 Retriever 방식을 시도하되 실패 시 기존 방식으로 폴백하는 방식으로 점진적 전환이 가능합니다. Document 객체를 기존 딕셔너리 형태로 변환하는 어댑터 함수를 만들어 호환성을 보장할 수 있습니다.

### **고급 검색 패턴 구현**
Document 객체와 LCEL 파이프라인을 완전히 통합하여 Retriever → Context Formatting → Prompt → Model까지 하나의 체인으로 연결할 수 있습니다. 이를 통해 검색부터 답변 생성까지의 전 과정이 자동화됩니다.

## 🚀 **권장사항**

### **즉시 적용 가능한 개선**
1. **QnA 에이전트**: 현재 Function Calling에서 Retriever Tool로 전환하면 Document 객체 활용으로 더 간단하고 강력한 검색이 가능합니다
2. **이론 생성**: MultiQueryRetriever + Document 객체로 다양한 관점의 자료를 자동으로 수집하고 구조화할 수 있습니다
3. **메타데이터 활용**: Document 객체의 메타데이터로 출처 추적, 품질 필터링, 디버깅이 훨씬 수월해집니다

### **Document 객체의 핵심 가치**
- **일관성**: 모든 LangChain 도구에서 표준화된 데이터 구조 사용
- **확장성**: 메타데이터를 통한 유연한 정보 관리  
- **호환성**: LangChain 생태계 내 완벽한 상호 운용성
- **추적성**: 디버깅 및 품질 관리가 매우 용이

### **장기적 개선 방향**
1. **Self-Query Retriever**: Document 메타데이터 기반 자동 필터링으로 검색 정확도 향상
2. **Parent Document Retriever**: 청크에서 전체 문서로 확장하여 컨텍스트 품질 대폭 개선  
3. **Document Transformers**: 검색 결과를 다양한 형태로 자동 변환하는 고도화

### **MVP 단계 적용 전략**
- 현재 방식도 충분히 잘 작동하므로 급하지 않음
- **QnA 에이전트만 우선적으로 Retriever + Document 객체로 전환을 강력 추천**
- Document 객체 사용으로 얻는 구조화, 일관성, 디버깅 편의성의 효과가 매우 큼
- 이론/퀴즈 생성은 현재 방식 유지 후 성능 개선 필요 시 단계적 적용

### **결론**
현재 구조가 이미 잘 설계되어 있어 Retriever + Document 객체 도입이 필수는 아니지만, **QnA 시스템의 품질 향상과 코드 유지보수성에는 확실한 개선**을 가져올 것입니다. 특히 스트리밍 QnA 구현 시 Document 객체의 구조화된 메타데이터가 큰 도움이 될 것입니다.

---


## 추가 개발이 필요한 미해결 이슈들

## AI 응용 프로그램은 if로 분기 설정이 아니라 ai가 모든 것을 통제해야 한다.
 - 현재 사용자 진단은 내가 정한 내부 기준 점수가 있다.
 - 사용자 질문과 제출한 답변을 토대로 ai가 판단하여 ai 입문, 실무 응용 2가지 사용자 유형을 자동으로 선택하게 해야 한다.
 - 추천은 해주되 유형 자동 선택보다는 사용자가 선택하도록 의도하긴 했으나 지금은 다시 해당 내용 고려 필요.

### quiz 생성에서 벡터 db 내용 활용하지 않음

### 학습 관련 페이지는 리팩터링이 되어 있지 않음 (08-25) -> 8월 27일 해결
 - 모바일 css제거
 - 부트스트랩 적용
 - scss nesting 문법
 - 전역 변수(variables.scss)활용

## 학습 관련 페이지 로직은 정리할 필요가 있습니다. (08-25) -> 8월 28일 해결
 - learningStore.js, learningService.js
 - 로컬 스토리지 저장과 pinia store 저장 등이 혼합되어 문제가 많은 상태.
 - 무슨 조건인지 모르겠는데 대시보드 갔다가 학습하기 누르면 학습 데이터 오기 전에 로딩 중 인디케이터가 떠야 하는데 어느 폴백 데이터인지 몰라도 다른 내용 표시되다가 원래 내용으로 갑작스럽게 교체

### 1. 세션 횟수 영속성 문제

**문제**: `current_session_count`가 데이터베이스에 저장되지 않음
- `current_session_count` 필드가 TutorState(메모리)에만 존재
- SessionService가 세션 완료 후 사용자 상태를 지우면 카운트가 0으로 초기화됨
- 사용자가 새 세션을 시작하여 세션 제한(섹션당 최대 1회 재학습)을 우회할 수 있음

**영향**:
- 세션 재시도 제한 적용이 무효화됨
- 사용자가 적절한 추적 없이 동일한 섹션을 반복적으로 재시도할 수 있음
- 세션 통계가 부정확해짐

**필요한 해결책**:
- `user_progress` 테이블에 `current_session_count` 컬럼 추가
- SessionManager가 세션 카운트를 데이터베이스에 저장하도록 업데이트
- SessionService가 세션 시작 시 데이터베이스에서 세션 카운트를 로드하도록 수정

---

### 2. 세션 요약 연속성 문제

**문제**: `recent_sessions_summary`가 세션 간에 보존되지 않음
- 세션 요약이 TutorState 메모리에만 저장됨
- SessionService가 세션 완료 후 `self._clear_user_state()`를 호출하여 모든 요약 손실
- 다음 세션이 이전 세션 기록에 대한 정보 없이 시작됨

**영향**:
- 세션 간 연속성 손실
- QnA 에이전트가 이전 학습 맥락을 참조할 수 없음
- 사용자가 최근 학습 진행 상황을 추적하지 못함

**필요한 해결책**:
- `user_session_summaries` 데이터베이스 테이블 생성
- 최근 5개 세션 요약을 데이터베이스에 저장
- 새 세션 상태 초기화 시 최근 요약 로드
- 대안: `user_progress` 테이블에 요약용 JSON 컬럼 추가

---

### 3. State 관리 아키텍처 격차

**근본 원인**: Stateful LangGraph 워크플로우와 Stateless 세션 관리 간의 불일치
- LangGraph 워크플로우는 상호작용 간 지속적인 상태를 기대
- SessionService는 메모리 정리와 함께 상태 없는 접근 방식을 구현
- 데이터베이스 스키마가 모든 상태 지속성 요구사항을 지원하지 않음

**권장 아키텍처 검토**:
- 하이브리드 접근법 평가: 중요한 상태 필드를 데이터베이스에 저장
- 복잡한 워크플로우 연속성을 위한 세션 상태 직렬화 고려
- 각 세션 후 완전한 상태 정리가 필요한지 검토

---

*최종 업데이트: 2025-08-23*  
*우선순위: 높음 - 이러한 문제들은 핵심 기능과 사용자 경험에 영향을 미침*